---
id: business-logic
sidebar_label: Handling Business Logic
title: Handling Business Logic
---

Conversational assistants often have user goals that involve collecting a bunch of information
from the user before being able to do something for them. For
example, in the banking industry you may have a user goal of transferring money, where you
need to collect information about which account to transfer from, whom to transfer to and the
amount to transfer. This type of behavior can and should be handled in a rule based way, as it
is clear how this information should be collected.

Here's a concrete example from Sara, the Rasa assistant. The user wants to <!--TODO-->,
and for this we need to gather a few pieces of information:

```yaml
## TODO example convo
```

This page is a guide on handling business logic. You can use the example
configuration and training data below to build an assistant that can handle a conversation
like the one above, or you can apply the guidelines to your own use case. 

## Concepts

### Forms

Forms work by looping over a set of required information until all information is gathered from the user.
The information is stored in [`slots`](domain.mdx#slots). Once all the required slots are filled,
the bot addresses the user's original request.

A form's happy path should be defined as a [rule](#rules), which means you'll need to add the [`RulePolicy`](policies.mdx#rulepolicy)
to your policies in your configuration file:

```yaml
policies:
  - name: RulePolicy
```

#### Required Slots

For the <!--todo--> use case, we want to collect the following information about the user:

<!--TODO-->

We define a form in our domain file with a slot for each piece
of required information:

```yaml
forms:
## TODO
```

We need to add all the slots our form is using to the domain. Slots filled by
forms are usually `unfeaturized`, since their value doesn't change
the flow of the conversation.

```yaml
slots:
## TODO
```

#### Filling Slots

[`Slot mappings`](forms.mdx#slot-mappings) define how a slot in a form can be filled.
By default, a slot will be filled by an entity with the same name.
You can change this behaviour by specifying slot mappings in your form definition.

For this example, 
<!--TODO-->

```yaml
entities:
## TODO
```

#### Requesting Slots

To specify how the bot should ask for the required information,
you define [`responses`](domain.mdx#responses) called `utter_ask_{slotname}` in your domain. 
For the <!--TODO--> example, our responses could look like this:

```yaml
responses:
## TODO
```

#### Completing the Form

Once all required slots have been filled, the bot can act on the
information it has collected. Depending on the use case, the assistant
might just respond with a message, or take a more complicated action behind
the scenes before responding to the user.

In this case, we want the bot to <!--TODO-->, so we define a custom action to do that:

```python
## TODO 
```



## Training Data

### Rules

All the slot collection happens inside the form, and
therefore doesn't need to be covered explicitly by a rule. 
You need two rules for a form's happy path: 
One to activate it, and one to submit it. 


```yaml
rules:
  - rule: activate form
    steps:
      - intent: # todo trigger intent
      - action: _form
  - rule: submit form
    steps:
      - form: _form
      - form: null
      - action: action_ #todo submit
```

By splitting up the activation and submission of the form, 
the rules will still apply if the user provides 
[unexpected input](chitchat-faqs.mdx)


### NLU Training Data

You'll need to add examples for the intent that should activate the form, as well as 
examples for how the user will provide the required information.

#### Form Activation Intent(s)

You need to provide training examples for the
intent(s) should activate the form.
For the example use case, we want the intent <!--todo--> to activate the form, 
so we add the following examples:

```yaml
nlu:
## TODO
```

#### Form Filling Intent(s)

While the form is filling slots, it will not pay attention to which intent was predicted 
unless:
 - a slot mapping explicitly asks for or excludes an intent or
 - an intent is involved in a different, competing rule

<!-- TODO instructions depending on whether all slots are filled from entities or not-->

## Putting it all together

Once you've done the following, you can train your bot and try it out!

- [ ] Defined your form and added the required slots to the domain
- [ ] Added `RulePolicy` to your policies in `config.yml`
- [ ] Added rules for activating and submitting the form
- [ ] Added examples for the intent to activate your form
- [ ] Added examples for the intent(s) to fill the required slots
- [ ] Defined an action or response for the bot to take when the form is completed
- [ ] Updated your domain with new intents and actions you've defined

For this example, since a custom action is run when the form is completed, you will need to start
the custom action in another terminal window before starting `rasa shell`. Make
sure to uncomment the `action_endpoint` in your `endpoints.yml` to make Rasa
aware of the action server that will run our form:

```yaml
action_endpoint:
 url: "http://localhost:5055/webhook"
```
