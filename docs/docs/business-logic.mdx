---
id: business-logic
sidebar_label: Handling Business Logic
title: Handling Business Logic
---

Conversational assistants often have user goals that involve collecting a bunch of information
from the user before being able to do something for them. For
example, in the banking industry you may have a user goal of transferring money, where you
need to collect information about which account to transfer from, whom to transfer to and the
amount to transfer. This type of behavior can and should be handled in a rule based way, as it
is clear how this information should be collected.

Here's a short adapted example from Sara, the Rasa assistant. The user wants to subscribe to the newsletter,
and for this we need to gather one piece of information, namely the user's email. We also want the user to confirm 
before subscribing them:

```yaml
User: I want to subscribe to the newsletter
    Sara: Sure thing! What's your email address?
User: user@example.com
    Sara: Do you want me to send you the Rasa newsletter at user@example.com?
          [yes]
          [no]
User: Yes
    Sara: We sent a confirmation email to user@example.com.
```

This page is a guide on handling business logic. You can use the example
configuration and training data below to build an assistant that can handle a conversation
like the one above, or you can apply the guidelines to your own use case. 

## Concepts

### Forms

Forms work by looping over a set of required information until all information is gathered from the user.
The information is stored in [`slots`](domain.mdx#slots). Once all the required slots are filled,
the bot addresses the user's original request.

A form's happy path should be defined as a [rule](#rules), which means you'll need to add the [`RulePolicy`](policies.mdx#rulepolicy)
to your policies in your configuration file:

```rasa-yaml
policies:
  - name: RulePolicy
```

#### Required Slots

For the newsletter subscription example, we want to collect the user's email and confirmation.

We need to add all the slots our form is using to the domain. Slots filled by
forms are usually `unfeaturized`, since their value doesn't change
the flow of the conversation. 

```rasa-yaml
slots:
  email:
    type: unfeaturized
  confirmation:
    type: unfeaturized
```

We define a form in our domain file with a slot and [slot mappings](forms.mdx#slot-mappings) for each piece
of required information:

```rasa-yaml
forms:
  subscribe_form:
    email:
    - type: from_entity
      entity: email
    confirmation:
    - type: from_intent
      intent: affirm
      value: true
    - type: from_intent
      intent: deny
      value: false
```

#### Filling Slots

[`Slot mappings`](forms.mdx#slot-mappings) define how a slot in a form can be filled.
By default, a slot will be filled by an entity with the same name.

The `email` slot is filled from the entity of the same name. Entities like emails 
are best extracted using the [`DucklingEntityExtractor`](entity-extractors.mdx#ducklingentityextractor)
in your NLU pipeline:

```rasa-yaml
language: en
pipeline:
# other components
- DucklingEntityExtractor:
  dimensions: ["email"]
```

The `confirmation` slot is 
filled based on the user's intent: If it is `affirm`, it'll be `true`, if it is
`deny`, it'll be `false`. You can
define the bot's response for asking for confirmation with buttons, so that the user can
click "yes" or "no" to trigger `affirm` and `deny` (see next section).


## Validating Slots

Often, you'll want to validate the user's input before accepting it,
for example by checking an email against a database to verify if the user is already subscribed.
See the docs on [validating form input](forms.mdx#validating-form-input) for more information
about validation actions. 


#### Requesting Slots

To specify how the bot should ask for the required information,
you define [`responses`](domain.mdx#responses) called `utter_ask_{slotname}` in your domain. 
For the newsletter subscription example, the responses look like this:

```rasa-yaml
responses:
  utter_ask_email:
  - text: Sure thing! What's your email address?
  utter_ask_confirmation:
  - text: Do you want me to send you the Rasa newsletter at {email}?
    buttons:
    - payload: /affirm
      title: Yes
    - payload: /deny
      title: No
```

#### Completing the Form

Once all required slots have been filled, the bot can act on the
information it has collected. Depending on the use case, the assistant
might just respond with a message, or take a more complicated action behind
the scenes before responding to the user.

For the newsletter subscription example, the email would usually be added to a database. 
In this case, the bot will just utter a response, but the response will vary based 
on whether the user confirms or not:


```python
class ActionSubscribeUser(Action):
    def name(self):
        return "action_subscribe_user"

    def run(self, dispatcher, tracker, domain):
        confirmation = tracker.get_slot("confirmation")

        if confirmation:
          email = tracker.get_slot("email")

          # Code here for adding user's email to database

          dispatcher.utter_message(
              template="utter_subscribed"
          )
        else:
          dispatcher.utter_message(
              template="utter_cancelled"
          )

        return []
```



## Training Data

### Rules

All the slot collection happens inside the form, and
therefore doesn't need to be covered explicitly by a rule. 
You need two rules for a form's happy path: 
One to activate it, and one to submit it. 


```rasa-yaml
rules:
  - rule: activate form
    steps:
      - intent: subscribe_newsletter
      - action: subscribe_form
  - rule: submit form
    steps:
      - form: subscribe_form
      - form: null
      - action: action_subscribe_user
```

By splitting up the activation and submission of the form, 
the rules will still apply if the user provides 
[unexpected input](unexpected-input.mdx) or interrupts
the form with [chitchat](chitchat-faqs.mdx).


### NLU Training Data

You'll need to add examples for the intent that should activate the form, as well as 
examples for how the user will provide the required information.

#### Form Activation Intent(s)

You need to provide training examples for the
intent(s) that should activate the form.
For the newsletter subscription use case, we want the intent `subscribe_newsletter` to activate the form:

```rasa-yaml
nlu:
- intent: subscribe_newsletter
  examples: |
    - Subscribe me to the newsletter please
    - I want to get news from Rasa
    - Send me the newsletter
```

#### Form Filling Intent(s)

While the form is filling slots, it will not pay attention to which intent was predicted 
unless:
 - a slot mapping explicitly asks for or excludes an intent or
 - an intent is involved in a different, competing rule

For the newsletter subscription example, the `confirmation` slot is mapped to two intents,
so you need to add training data for these intents if you expect users to provide
free form input and not just use the buttons. 

For the `email` slot, you can add examples to a generic `inform` intent. You don't need
to annotate any entities, since `DucklingEntityExtractor` is a rule-based extractors
that isn't trained on your training data:


```rasa-yaml
nlu:
- intent: affirm
  examples: |
    - Yes
    - yes, please
    - yup
- intent: deny
  examples: |
    - no don't
    - no
    - no I don't want that
- intent: inform
  examples: |
    - example@example.com
    - my email is bat@man.com
    - send it to my@email.com
```


## Putting it all together

Forms require a few more pieces than other conversation patterns,
but in turn they can greatly simplify the logic of collecting user 
information. To define a minimal form like the newsletter subscription
example above, this is a summary of what you'll need to do:

- [ ] Define the form with slot mappings
- [ ] Add all required slots to the domain
- [ ] Add `RulePolicy` to your policies in `config.yml`
- [ ] Add rules for activating and submitting the form
- [ ] Add examples for the intent to activate your form
- [ ] Add examples for the intent(s) to fill the required slots
- [ ] Define an action or response for the bot to take when the form is completed
- [ ] Update your domain with new intents and actions you've defined

To try out your newly defined form, retrain the bot and start `rasa shell`.
If your final action is a custom action, you'll need to start the action server 
in a seperate terminal when running `rasa shell`. If you're using `DucklingEntityExtractor` to extract
entities, you'll need to start Duckling in the background as well
(see the [instructions for running Duckling](entity-extractors.mdx#ducklingentityextractor)).
