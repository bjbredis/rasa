---
id: unexpected-input
sidebar_label: Handling Unexpected Input
title: Handling Unexpected Input
---

One thing you can count on when building a conversational assistant is that users
will say unexpected things. Unexpected input is a deviation from the [`happy path`](glossary.mdx#happy_unhappy_paths)
that you have defined.  For example:

- A user walks away in the middle of a conversation about their subscription, then comes back
and says "hi!"
- A user asks "Why do you need to know that?" when the bot asks for their email address.

This page is a guide on methods for handling unexpected input that is still within your bot's domain. 
Depending on what kind of unexpected
input you're trying to handle, some or all of the methods describe may be applicable for you. This guide
is not about disambiguating user input or handling out-of-scope questions; for these cases see 
the guide on [fallback and human handoff](fallback-handoff.mdx)


## Concepts

There are two kinds of unexpected input: generic interjections, and contextual interjections.
Generic interjections are interruptions that should always get the same response regardless of the 
conversation context. [FAQs and chitchat](#chitchat-faqs) are common generic interjections.
A contextual interjection is one whose response depends on the conversation context. 
For example, if a user asks "Why do you need that?", the answer will depend on what the bot just
asked for. 

### When to Account for Interruptions

The decision to handle unexpected user input should always come from reviewing
real conversations. You should first build part of your assistant, test it with real users
(whether that's your end user, or your colleague) and then add what's missing. You shouldn't
try to implement every possible edge case that you think might happen, because in the end
your users may never actually behave in that way.
[Rasa X](https://rasa.com/docs/rasa-x/)
is a tool that can help you review conversations and make these types of decisions.

### `UserUtteranceReverted`

If you have generic interjections that should always have the same response no
matter the context, you can define 
short rules for the interjecting intents and the responses that should always be returned. 
When combined with a forgetting mechanism, this won't affect your dialogue history either, so
you won't need to write any stories showing the interruption.

For example, let's say you see users having conversations like the following one with
your assistant, where they write a greeting in the middle of a conversation -
maybe because they were gone for a few minutes:

<img alt="Greeting Interjection" src={useBaseUrl("/img/greet_interjection.png")} width="240" />

The greet intent is a good example where we will always give the same response and
yet we don't want the intent to affect the dialogue history. To do this, the response
must be an action that returns the `UserUtteranceReverted()` event to remove the
interaction from the dialogue history.

First, make sure the `RulePolicy` is in the policies section of your configuration file:

```rasa-yaml
policies:
  # Other policies
  - name: RulePolicy
```

Next, we need to define `action_greet`. Add the following action to your `actions.py` file:

```python
from rasa_sdk import Action
from rasa_sdk.events import UserUtteranceReverted

class ActionGreetUser(Action):
"""Revertible mapped action for utter_greet"""

def name(self):
    return "action_greet"

def run(self, dispatcher, tracker, domain):
    dispatcher.utter_message(template="utter_greet")
    return [UserUtteranceReverted()]
```

This action will return the `utter_greet` response to the user, before removing the interaction from the dialogue history.

## Data

### Rules for Reverted Utterances

If you've defined an action that includes `UserUtteranceReverted`, you only
need to add a single rule for it, since it won't affect the dialogue history:

```rasa-yaml
rules:
- rule: greet user
  steps:
  - intent: greet
  - action: action_greet_user
```

You'll also need to add any responses your action runs to your domain:

```rasa-yaml
responses:
  utter_greet: Hi there! 
```

### Stories with Interjections

You can't revert every kind of interjection. In these cases,
you need stories with interruptions in them. 

#### Generic Interjections

Generic interjections that aren't reverted should be added to stories wherever you see them occurring.

If you're using the [`ResponseSelector`](components/selectors.mdx#responseselector)
for any generic interjection intents, you'll only need to include one kind of interruption for each retrieval
intent. For example, if you had an `faq` retrieval intent,
to account for a user asking an FAQ in the middle of a form, you'd write a story like this:

```
stories:
- story: form with faq interruption
  steps:
  - intent: contact_sales
  - action: sales_form
  - intent: faq           <!--generic interruption-->
  - action: respond_faq   <!--retrieval action response-->
  - action: sales_form
  - active_loop: sales_form
  - active_loop: null
  - action: action_submit_salesform
```

You can write similar stories for any other generic interruption intent and response,
whether or not it's a retrieval intent.

#### Contextual Interjections

Handling contextual interjections is similar to handling [contextual conversations](contextual-conversations.mdx)
in general. 

One common case of contextual interjections is during slot filling for [form](forms.mdx), where the user
asks “Why do you need to know that?” or "Can you explain that?". 
The response should differ for each slot. For example:

<img alt="Contextual Interjection" src={useBaseUrl("/img/contextual_interjection.png")} width="240" />

Since we want the `requested_slot` to influence the conversation,
we need to make the `requested_slot` featurized, and assign it the categorical type:

```rasa-yaml
slots:
  requested_slot:
    type: categorical
    values:
      - business_email
      - company
      - person_name
      - use_case
      - budget
      - job_function
```

This means that the dialogue model will pay attention to the value of the slot when making a prediction
(read more about other [featurized slots](./domain.mdx#slots), whereas
unfeaturized slots are only used for storing information. 

You can then write stories whose paths diverge based on the value of `requested_slot`, for example:

```
stories:
- story: form with email interruption
  steps:
  - intent: contact_sales
  - action: sales_form
  - form: sales_form
  - slot_was_set:
    - requested_slot: email <!--bot just asked for the user's email-->
  - intent: ask_why_needed
  - action: utter_why_email
  - action: sales_form

- story: form with company interruption
  steps:
  - intent: contact_sales
  - action: sales_form
  - form: sales_form
  - slot_was_set:
    - requested_slot: company <!--bot just asked for the user's company-->
  - intent: ask_why_needed
  - action: utter_why_company
  - action: sales_form
```


## Putting it all together

How you handle unexpected input depends on whether the response should be 
context sensitive or not.

For generic interjections:
  - [ ] Define rules for single-turn interactions with actions that return the `UserUtteranceReverted` event
  - [ ] Use the `ResponseSelector` for [FAQ and chitchat interruptions](chitchat-faqs.mdx)

For contextual interjections:
  - [ ] Make `requested_slot` a categorical slot (for forms)
  - [ ] Write rules for context-specific responses to interjections, using slot values where applicable
